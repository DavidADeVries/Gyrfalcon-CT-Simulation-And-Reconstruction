function [reconDataSet, sinograms, videosFrames] = firstGenFilteredBackProjectionAlgorithm(...
    firstGenProjectionData,...
    scanAngles, sourceStatingLocationInM,phantomSliceDimensions, phantomVoxelDimensionsInM, phantomLocationInM, detectorWidthInM, filterType, applyRampFilter, applyBandlimiting, interpolationType)
% function [reconDataSet, sinograms, videosFrames] = firstGenFilteredBackProjectionAlgorithm(firstGenProjectionData, filterType, applyRampFilter, applyBandlimiting, interpolationType)

numSlices = length(firstGenProjectionData);

reconDataSet = cell(1, numSlices);
sinograms = cell(1, numSlices);
videosFrames = cell(1, numSlices);

dims = size(numSlices{1});

numAngles = dims(2); %num cols
numDetectors = dims(1); %num rows

for i=1:numSlices
    projectionData = firstGenProjectionData{i}; %each column contains on angle of projection data (aka sinogram!)
    
    % filter projection data
    for j=1:numAngles
        projectValues = projectionData(:,j)';
        
        filteredProjectionData = filterProjectionValuesRedo(projectValues, filterType, applyRampFilter, applyBandlimiting, detectorWidthInM);
        
        projectionData(:,j) = filteredProjectionData';
    end
    
    centreOfDetectorsPlusEdgeInM = calcCentreOfDetectorsPlusEdge(numDetectors, detectorWidthInM);
    
    tDiscrete = centreOfDetectorsPlusEdgeInM;
    
    interpsOfProjections = cell(1, numAngles);
    
    for j=1:numAngles
        % create piecewise 'interp' function for easy evaluation
        projData = [projectionData(1,j) projectionData(:,j)' projectionData(end,j)]; %specific edge of detector values
                
        zeroBeyondBounds = true;
        interpForAngle = interpolationType.createInterpForKnownVals(tDiscrete, projData, zeroBeyondBounds);
        
        interpsOfProjections{j} = interpForAngle;
    end
    
    sliceRecon = zeros(phantomSliceDimensions);
    frames = zeros([phantomSliceDimensions numAngles]);
    
    xIndices = 1:1:phantomSliceDimensions(1);
    yIndices = 1:1:phantomSliceDimensions(2);   
        
    for k = 1:numAngles
        ang = scanAngles(k);
        projValuesInterp = interpsOfProjections{j};
        
        % create grid of all x,y index combinations
        [xxIndices, yyIndices] = meshgrid(xIndices,yIndices);
        
        % find coresponding (x,y) values relative to (0,0)
        % phantomLocation gives top left corner in xy plane
        xxVals = phantomLocationInM(1) + (xxIndices * phantomVoxelDimensionsInM(1)) + phantomVoxelDimensionsInM(1)/2;
        yyVals = phantomLocationInM(2) - (yyIndices * phantomVoxelDimensionsInM(2)) - phantomVoxelDimensionsInM(2)/2;
        
        t = xxVals.*cosd(ang) + yyVals.*sind(ang);
        
        dims = size(t);
        
        tRowVector = reshape(t, 1, dims(1)*dims(2));
        
        projValueAtTRowVector = ppval(projValuesInterp, tRowVector);
        
        projValueAtT = reshape(projValueAtTRowVector, dims(1), dims(2));
        
        sliceRecon(xxIndices,yyIndices) = sliceRecon(xxIndices,yyIndices) + projValueAtT;
        
        frames(:,:,k) = sliceRecon;
    end
    
    sliceRecon = sliceRecon .* (pi/numAngles);
    
    % set outputs
    reconDataSet{i} = sliceRecon;
    sinograms{i} = projectionData;
    videosFrames{i} = frames;
end

end

% specifics the centre of detector and the edge
function centreOfDetectorsPlusEdgeInM = calcCentreOfDetectorsPlusEdge(numDetectors, detectorWidthInM)
    
    bound = ((numDetectors - 1) / 2) * detectorWidthInM;
    
    centreOfDetectorsInM = -bound:detectorWidthInM:bound;
    
    edge = (numDetectors / 2) * detectorWidthInM;
    
    centreOfDetectorsPlusEdgeInM = [-edge centreOfDetectorsInM edge];
end